#include<stdio.h>
#include<stdlib.h>
#include<stdbool.h>
#include<time.h>
#include <string.h>

#define MAX_PROCESSOS 64
#define MAX_ACCESS 128
#define MAX_PAGES 1024
#define INT_MAX 999
/* Integrantes
    - Andre Doerner Duarte - 10427938
    - Matheus Leonardo Cardoso Kroeff - 10426434
    - Naoto Ushizaki - 104374445
*/

//Struct para config. da memória:
typedef struct{
    int num_frames;
    unsigned int tamanho_pag;
    int quant_processos;
    int pid[MAX_PROCESSOS];
    unsigned int tamanho_mem_virtual[MAX_ACCESS];
} ConfigMemoria;
ConfigMemoria CM;

//Struct para acessos:
typedef struct{
    unsigned int quant_acessos;
    int pid[MAX_ACCESS];
    unsigned int end_mem_virtual[MAX_ACCESS];
} Acessos;

//Struct para Tabela de Páginas:
typedef struct{
    unsigned int end_virtual;
    unsigned int num_frame;
    unsigned int valid_bit;
    unsigned int referenced_bit;
    unsigned int frame;
    int loaded_time;
    int pid;
} TabelaPagina;

//Struct para tradução de endereços:
typedef struct{
    unsigned int pagina;
    unsigned int deslocamento;
    unsigned int end_fisico;
} Traducao;

typedef struct{
    bool ocupied;
    int pagina_virtual;
} Frame;

typedef struct{
    unsigned int pagina;
    unsigned int frame;
    int hit;
    int removed_pagina;
    int removed_frame;
    int removed_pid;
} FormatoSaida;

// Esse tempo é usado para o -> FIFO <-
int tempo_global_fifo = 0;


//------------------------------------------------------------------//
/**
 * @brief Função -> leitura do arquivo de configuração
 * @param arquivo_config -> nome do arquivo de configuração
 * @param ConfigMemoria -> struct com as informações do arquivo de configuração
 */
ConfigMemoria arquivo_config(const char *config_1){
    ConfigMemoria ptr;
    
    FILE *config_file = fopen(config_1, "r");
    // Verificação:
    if (config_file == NULL) {
        perror("ERROR opening File <arquivo_config>");
        exit(1);
    }
    
    // Carrega as informacoes do arquivo para struct:
    fscanf(config_file, "%d", &ptr.num_frames);
    fscanf(config_file, "%u", &ptr.tamanho_pag);
    fscanf(config_file, "%d", &ptr.quant_processos);
    
    /* Para debugar:
    printf("\nQuant. frames: %d", ptr.num_frames);
    printf("\nTamanho da página: %u", ptr.tamanho_pag);
    printf("\nProcessos: %d\n", ptr.quant_processos);
    */

    for (int a = 0; a < ptr.quant_processos && a < MAX_PROCESSOS; a++) {
        if (fscanf(config_file, "%d %u", &ptr.pid[a], &ptr.tamanho_mem_virtual[a]) != 2) {
            printf("Erro ao ler processo %d\n", a);
            break;
        }
    }

    fclose(config_file);
    return ptr;
}
/**
 * @brief Função -> leitura do arquivo de acessos
 * @param arquivo_acessos -> nome do arquivo de acessos
 * @param Acessos -> struct com as informações do arquivo de acessos
 */
Acessos arquivo_acessos(const char *acessos_1){
    Acessos ptr;
    ptr.quant_acessos = 0;
    
    FILE *file = fopen(acessos_1, "r");
    if (file == NULL) {
        perror("ERROR opening File <arquivo_acessos>");
        exit(1);
    }
    // Carrega as informacoes do arquivo para struct:
    while (ptr.quant_acessos < MAX_ACCESS && fscanf(file, "%d %u", &ptr.pid[ptr.quant_acessos], &ptr.end_mem_virtual[ptr.quant_acessos]) == 2) {
        ptr.quant_acessos++;
    }

    fclose(file);
    return ptr;
}

/**
 * @brief Função -> tradução de endereços
 * @param T -> struct de tradução
 * @param endereco -> endereço virtual
 * @param frames -> número de frames
 * @param CM -> struct de configuração de memória
 */
Traducao traducao_endereco(unsigned int endereco, ConfigMemoria CM, TabelaPagina TP[]){
    Traducao T;

    T.pagina = endereco / CM.tamanho_pag;
    T.deslocamento = endereco % CM.tamanho_pag;

    if(TP[T.pagina].valid_bit == 1){
        unsigned int frame = TP[T.pagina].num_frame;
        T.end_fisico = (frame * CM.tamanho_pag) + T.deslocamento;
    } else {
        T.end_fisico = (unsigned int)-1;
    }

    return T;
}

// Função que checa se página existe na memória física:
int checkHIT(TabelaPagina TP[], unsigned int pagina){
    if(TP[pagina].valid_bit == 1){
        return TP[pagina].num_frame;
    } else {
        return -1;
    }
}

/**                            
 * @brief Função do algoritmo FIFO (First In First Out)
 * @param TabelaPagina -> Chama a struct table pagina
 * @param num_frames -> quantidade de frames a serem acessadas
 */
int algFIFO(TabelaPagina TP[], unsigned int num_frames){
    int older_page = -1;
    clock_t maior_tempo = (clock_t)~0;

    for(int idx = 0; idx < MAX_PAGES; idx++){
        if (TP[idx].valid_bit && TP[idx].num_frame >= 0 && TP[idx].num_frame < (int)num_frames) {
            if (TP[idx].loaded_time < maior_tempo){
                maior_tempo = TP[idx].loaded_time;
                older_page = idx;
            }
        }
    }
    return older_page;
}
/**                            
 * @brief Função do algoritmo CLOCK (Second Chance):
 * @param TabelaPagina -> Chama a struct table pagina
 * @param num_frames -> quantidade de frames a serem acessadas
 */
unsigned int algCLOCK(TabelaPagina TP[], unsigned int num_frames) {
    static unsigned int ponteiro = 0; // ponteiro circular

    while (1) {
        // percorre todas as páginas para achar quem ocupa o frame atual
        for (unsigned int pag = 0; pag < MAX_PAGES; pag++) {
            if (TP[pag].valid_bit && TP[pag].num_frame == ponteiro) {
                // caso 1: bit de referência = 0 -> vítima encontrada
                if (TP[pag].referenced_bit == 0) {
                    unsigned int vitima = pag;
                    ponteiro = (ponteiro + 1) % num_frames; // avança ponteiro
                    return vitima;
                } else {
                    // caso 2: bit de referência = 1 -> segunda chance
                    TP[pag].referenced_bit = 0;
                }
            }
        }
        // avança ponteiro circularmente
        ponteiro = (ponteiro + 1) % num_frames;
    }
}


/**
 * @brief Função que trata o caso de PAGE FAULT
 * @param TP -> Struct de Tabela Página
 * @param CM -> Struct de Configuração de Memória
 * @param pag_virtual -> Recebe a página virtual para ser alocada em novo frame
 * 
 * @return Tabela atualizada com a página em novo frame
 */
void PageFaultCorrection(TabelaPagina TP[], ConfigMemoria CM, int pag_virtual, int pid_atual, const char *algoritmo){//int *removed_page, int *removed_frame, int *pid_removido){
    /*
    *removed_page = -1;
    *removed_frame = -1;
    *pid_removido = -1;*/
    int frame_free = -1; 

    // Cenário de procura por um frame livre primeiro:
    for(int d = 0; d < CM.num_frames; d++){
        int occupied = 0;
        // Caso de se tiver frame livre:
        for(int o = 0; o < MAX_PAGES; o++){
            if(TP[o].valid_bit && TP[o].num_frame == d){
                occupied = 1;
                break;
            }
        }
        if(!occupied){
            frame_free = d;
            break;
        }
        
    }

    if(frame_free != -1){
        TP[pag_virtual].loaded_time = clock(); // Comeca a contar o tempo para o FIFO
        TP[pag_virtual].end_virtual = pag_virtual;
        TP[pag_virtual].num_frame = frame_free;
        TP[pag_virtual].pid = pid_atual;
        TP[pag_virtual].valid_bit = 1;
        TP[pag_virtual].referenced_bit = 1;
        return;
    } else {
        int eliminate_page = -1;
        // Cenário 2: PAGE_FAULT -> Pagina não está na memória física:
        if (strcmp(algoritmo, "fifo") == 0) {
            eliminate_page = algFIFO(TP, CM.num_frames);
        } else if (strcmp(algoritmo, "clock") == 0) {
            eliminate_page = algCLOCK(TP, CM.num_frames);
        } else {
            printf("Algoritmo desconhecido: %s\n", algoritmo);
            exit(1);
        }

        int chosen_frame = TP[eliminate_page].num_frame;
        int pid_victim = TP[eliminate_page].pid;
        double maior_tempo_FIFO = (double)(clock() - TP[eliminate_page].loaded_time) / CLOCKS_PER_SEC;
        
        // Atualizando ponteiros:
        /*
        *removed_page = eliminate_page;
        *removed_frame = chosen_frame;
        *pid_removido = pid_victim;*/

        // Zerando os bits (retirada de páginas):
        TP[eliminate_page].valid_bit = 0;
        TP[eliminate_page].referenced_bit = 0;
        TP[eliminate_page].num_frame = -1;

        // Recolocando na table de paginas:
        TP[pag_virtual].loaded_time = clock();
        TP[pag_virtual].end_virtual = pag_virtual; // Atualizando pagina
        TP[pag_virtual].num_frame = chosen_frame;
        TP[pag_virtual].pid = pid_atual;
        TP[pag_virtual].valid_bit = 1;
        TP[pag_virtual].referenced_bit = 1;

    }
}

/**
 * @brief Função -> tabela de páginas
 * @param TP -> struct da tabela de páginas
 * @param num_pag -> número de páginas
 * @param pag_virtual -> página virtual
 * @return unsigned int -> número do frame correspondente
 */

void tabela_pagina(TabelaPagina TP[], Acessos AC, ConfigMemoria CM, FormatoSaida FS[], int *total_access, int *total_PAGEFAULTS, const char *algoritmo){
    // Setando a tabela de páginas:
    for(int y = 0; y < MAX_PAGES; y++){
        TP[y].end_virtual = y;
        TP[y].num_frame = -1;
        TP[y].valid_bit = 0;
        TP[y].referenced_bit = 0;
        TP[y].loaded_time = 0;
    }

    *total_access = AC.quant_acessos;
    if(*total_access > MAX_ACCESS) *total_access = MAX_ACCESS;
    *total_PAGEFAULTS = 0;
    

    // Organizando end_virtual na tabela de páginas:
    for(int x = 0; x < *total_access; x++){
        Traducao T = traducao_endereco(AC.end_mem_virtual[x], CM, TP);
        unsigned int pag_virtual = T.pagina;
        int frame = checkHIT(TP, pag_virtual);

        // Cenário 1: HIT -> pagina está na memória física
        if(frame != -1){
            TP[pag_virtual].referenced_bit = 1;
            FS[x].hit = 1;
            FS[x].pagina = pag_virtual;
            FS[x].frame = TP[pag_virtual].num_frame;;
            FS[x].removed_frame = -1;
            FS[x].removed_pagina = -1;
            FS[x].removed_pid = -1;
        } else {
            // Cenário 2: página não está na memória física:
            (*total_PAGEFAULTS)++;
            //int removed_page, removed_frame, pid_removido;
            PageFaultCorrection(TP, CM, pag_virtual, AC.pid[x], algoritmo); //&removed_page, &removed_frame, &pid_removido);
            FS[x].hit = 0;
            FS[x].pagina = pag_virtual;
            FS[x].frame = TP[pag_virtual].num_frame;
            FS[x].removed_pagina = TP[pag_virtual].end_virtual;
            FS[x].removed_frame = TP[pag_virtual].num_frame;
            FS[x].removed_pid = TP[pag_virtual].pid;

        }
    }
}

void OUTPUT(TabelaPagina TP[], ConfigMemoria CM, FormatoSaida FS[], Acessos access, int idx_acesso, unsigned int pagina, unsigned int frame){
    unsigned int endereco = access.end_mem_virtual[idx_acesso];
    unsigned int pid = access.pid[idx_acesso];
    unsigned int deslocamento = endereco % CM.tamanho_pag;
    if(FS[idx_acesso].hit){
        printf("Acesso: PID %u, Endereço %u (Página %u, Deslocamento %u) -> "
           "HIT: Página %u (PID %u) já está no Frame %u\n", pid, endereco, pagina, deslocamento, pagina, pid, frame);
    } else {
        printf("Acesso: PID %u, Endereço %u (Página %u, Deslocamento %u) -> "
           "PAGE FAULT -> Página %u (PID %u) alocada no Frame %u\n", pid, endereco, pagina, deslocamento, pagina, pid, FS[idx_acesso].frame);
    }       
}

int main(int argc, char *argv[]){
    if (argc != 4) {
        printf("Uso correto: %s <algoritmo> <arquivo_config> <arquivo_acessos>\n", argv[0]);
        return 1;
    }

    const char *algoritmo = argv[1];         // "fifo" ou "clock"
    const char *config_file = argv[2];       // "tests/config_1.txt"
    const char *acessos_file = argv[3];      // "tests/acessos_1.txt
    
    ConfigMemoria CM = arquivo_config(config_file);
    Acessos AC = arquivo_acessos(acessos_file);
    TabelaPagina TP_FIFO[MAX_PAGES];
    TabelaPagina TP_CLOCK[MAX_PAGES];
    FormatoSaida FS_FIFO[MAX_ACCESS];
    FormatoSaida FS_CLOCK[MAX_ACCESS];

    int total_access_FIFO = 0;
    int total_pf_FIFO = 0;
    int total_access_CLOCK = 0;
    int total_pf_CLOCK = 0;

    // Para o caso de FIFO:
    if(strcmp(algoritmo, "fifo") == 0){
        tabela_pagina(TP_FIFO, AC, CM, FS_FIFO, &total_access_FIFO, &total_pf_FIFO, "fifo");

        for(int y = 0; y < AC.quant_acessos; y++){
            OUTPUT(TP_FIFO, CM, FS_FIFO, AC, y, FS_FIFO[y].pagina, FS_FIFO[y].frame);
        }
        printf("--- Simulação Finalizada (Algoritmo: <fifo>)\n");
        printf("Total de Acessos: %d\n", total_access_FIFO);
        printf("Total de Page Faults: %d\n", total_pf_FIFO);
    } else {
        tabela_pagina(TP_CLOCK, AC, CM, FS_CLOCK, &total_access_CLOCK, &total_pf_CLOCK, "clock");

        for(int t = 0; t < AC.quant_acessos; t++){
            OUTPUT(TP_CLOCK, CM, FS_CLOCK, AC, t, FS_CLOCK[t].pagina, FS_CLOCK[t].frame);
        }

        printf("--- Simulação Finalizada (Algoritmo: clock)\n");
        printf("Total de Acessos: %d\n", total_access_CLOCK);
        printf("Total de Page Faults: %d\n", total_pf_CLOCK);
    }
    return 0;
}
